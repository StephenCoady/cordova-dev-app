"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var apollo_link_1 = require("apollo-link");
var TestLink = (function (_super) {
    __extends(TestLink, _super);
    function TestLink() {
        var _this = _super.call(this) || this;
        _this.operations = [];
        return _this;
    }
    TestLink.prototype.request = function (operation) {
        this.operations.push(operation);
        return new apollo_link_1.Observable(function (observer) {
            if (operation.getContext().testError) {
                setTimeout(function () { return observer.error(operation.getContext().testError); }, 0);
                return;
            }
            setTimeout(function () { return observer.next(operation.getContext().testResponse); }, 0);
            setTimeout(function () { return observer.complete(); }, 0);
        });
    };
    return TestLink;
}(apollo_link_1.ApolloLink));
exports.TestLink = TestLink;
exports.assertObservableSequence = function (observable, sequence, initializer) {
    if (initializer === void 0) { initializer = function () { return undefined; }; }
    var index = 0;
    if (sequence.length === 0) {
        throw new Error('Observable sequence must have at least one element');
    }
    return new Promise(function (resolve, reject) {
        var sub = observable.subscribe({
            next: function (value) {
                expect({ type: 'next', value: value }).toEqual(sequence[index]);
                index++;
                if (index === sequence.length) {
                    resolve(true);
                }
            },
            error: function (value) {
                expect({ type: 'error', value: value }).toEqual(sequence[index]);
                index++;
                expect(undefined).toEqual(sequence[index]);
                resolve(true);
            },
            complete: function () {
                expect({ type: 'complete' }).toEqual(sequence[index]);
                index++;
                expect(undefined).toEqual(sequence[index]);
                resolve(true);
            }
        });
        initializer(sub);
    });
};
//# sourceMappingURL=TestUtils.js.map